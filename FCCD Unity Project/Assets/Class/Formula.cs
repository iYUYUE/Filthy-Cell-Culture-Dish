// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public static class Formula
	{
		public static int ExplorePop(Player pl){
			return (int)(Global.baseCapacity*(double)(0.5 + (double)pl.getExplorationLevel()/(double)Global.numTech));
		}
		public static double GrowthRate(int level) {
			return (((double) level) * 0.1 + 0.2)/Global.baseCapacity;
		}
		public static double GrowthRate(Player pl) {
			return GrowthRate (pl.getGrowthLevel ());
		}
		public static int GrowthCap(Player pl){
			int level = pl.getGrowthLevel ();
			return  GrowthCap (level);

		}
		public static int GrowthCap(int level) {
			if (level <= 0)
				return Global.baseCapacity;
			return Global.baseCapacity + level * 10;
		}
		
		public static int LosePop(Player Player1, Player PlayerX, int Pop1, int PopX) {
			return Math.Min((int)(((double)(Player1.getDefenseLevel() - PlayerX.getAttackLevel())/
			                       (double)(PlayerX.getAttackLevel() + Player1.getDefenseLevel() +1) ) * (double)(Pop1 * PopX)),(int)(- 0.05* (double)(Pop1 * PopX)))/Global.baseCapacity;
		}
		
		public static int GainPop(Player Player1, Player PlayerX, int Pop1, int PopX) {
			return Math.Max ((int)(((double)(Player1.getAttackLevel() - PlayerX.getDefenseLevel())/
			                        (double)(Player1.getAttackLevel() + PlayerX.getDefenseLevel()+1) ) * (double)(Pop1 * PopX)),0)/Global.baseCapacity;
		}
		
		public static double spreadThreshold(int level) {
			if (level < 0)
				return 0.9;
			if (level > 6)
				return 0.1+0.3;
			else
				return Global.numTech*0.1 - ((double) level) * 0.1+0.3;
		}

		
		public static double spreadThreshold(Player pl) {
			int level = pl.getExplorationLevel ();
			return spreadThreshold (level);
		}

		// float r range from 0 ~ 1 (100%)
		public static Color ColorLighter(Color origin, float r) {
			if (r == 0.0f)
				return new Color(1.0f, 1.0f, 1.0f);
			float rate = 2.0f - r;
			rate = (float)Math.Sqrt (rate);
			float newr = (origin.r * rate > 1.0f) ? 1.0f : origin.r * rate;
			float newg = (origin.g * rate > 1.0f) ? 1.0f : origin.g * rate;
			float newb = (origin.b * rate > 1.0f) ? 1.0f : origin.b * rate;
			return new Color(newr, newg, newb);
		}
		
		public static Color ColorMixer(List<Color> origins) {
			float newr = 0.0f;
			float newg = 0.0f;
			float newb = 0.0f;
			int count = 0;
			
			foreach (Color color in origins) {
				newr += color.r;
				newg += color.g;
				newb += color.b;
				count ++;
			}
			
			if(count == 0)
				return new Color(1.0f, 1.0f, 1.0f);
			
			newr = newr / (float)count;
			newg = newg / (float)count;
			newb = newb / (float)count;
			//			Debug.LogError ("newb: "+newb);
			
			return new Color(newr, newg, newb);
		}
		
	}
}

