// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public static class Formula
	{
		public static int ExplorePop(Player pl){
			return Global.baseCapacity*Global.numTech/10 + pl.getExplorationLevel()* Global.baseCapacity/Global.numTech;
		}
		public static double GrowthRate(int level) {
			return ((double) level) * 0.01 + 0.02;
		}
	
		public static int GrowthCap(int level) {
			if (level <= 0)
				return Global.baseCapacity;
			return Global.baseCapacity + level * 10;
		}
		
		public static int LosePop(Player Player1, Player PlayerX, int Pop1, int PopX) {
			return Math.Min((int)(((double)(Player1.getDefenseLevel() - PlayerX.getAttackLevel())/
			                       (double)(Player1.getAttackLevel() + PlayerX.getAttackLevel() + Player1.getDefenseLevel() + PlayerX.getDefenseLevel()+Global.numTech) ) * (double)(Pop1 * PopX)),(int)(- 0.05* (double)(Pop1 * PopX)))*50/Global.baseCapacity;
		}
		
		public static int GainPop(Player Player1, Player PlayerX, int Pop1, int PopX) {
			return Math.Max ((int)(((double)(Player1.getAttackLevel() - PlayerX.getDefenseLevel())/
			                        (double)(Player1.getAttackLevel() + PlayerX.getAttackLevel() + Player1.getDefenseLevel() + PlayerX.getDefenseLevel()+Global.numTech) - 0.05) * (double)(Pop1 * PopX)),0)*50/Global.baseCapacity;
		}
		
		public static double spreadThreshold(int level) {
			if (level < 0)
				return 0.9;
			if (level > 6)
				return 0.1+0.3;
			else
				return Global.numTech*0.1 - ((double) level) * 0.1+0.3;
		}
		
		// float r range from 0 ~ 1 (100%)
		public static Color ColorLighter(Color origin, float r) {
			if (r == 0.0f)
				return new Color(1.0f, 1.0f, 1.0f);
			float rate = 2.0f - r;
			rate = (float)Math.Sqrt (rate);
			float newr = (origin.r * rate > 1.0f) ? 1.0f : origin.r * rate;
			float newg = (origin.g * rate > 1.0f) ? 1.0f : origin.g * rate;
			float newb = (origin.b * rate > 1.0f) ? 1.0f : origin.b * rate;
			return new Color(newr, newg, newb);
		}
		
		public static Color ColorMixer(List<Color> origins) {
			float newr = 0.0f;
			float newg = 0.0f;
			float newb = 0.0f;
			int count = 0;
			
			foreach (Color color in origins) {
				newr += color.r;
				newg += color.g;
				newb += color.b;
				count ++;
			}
			
			if(count == 0)
				return new Color(1.0f, 1.0f, 1.0f);
			
			newr = newr / (float)count;
			newg = newg / (float)count;
			newb = newb / (float)count;
			//			Debug.LogError ("newb: "+newb);
			
			return new Color(newr, newg, newb);
		}
		
	}
}

