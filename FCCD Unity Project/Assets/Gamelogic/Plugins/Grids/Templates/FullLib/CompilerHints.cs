#if !IgnoreRectLib
//----------------------------------------------//
// Gamelogic Grids                              //
// http://www.gamelogic.co.za                   //
// Copyright (c) 2013 Gamelogic (Pty) Ltd       //
//----------------------------------------------//

// Auto-generated File

using System.Linq;
using System.Collections.Generic;

namespace Gamelogic.Grids
{
	/**
		Place holder class.

		@since 1.6
	*/
	public class __CellType{}

	/**
		This class provides static methods that ensure all the code is 
		generated by to AOT compiler for iOS. 

		The easiest way to use it is to copy the appropriate methods to
		one of your classes, modify the __CellType type, and call the methods.

		@since 1.6
	*/
	public static class __CompilerHints
	{

		public static bool __CompilerHint__Rect()
		{
			return __CompilerHint1__Rect() && __CompilerHint2__Rect();
		}

		/** 
			Call this method if you use a RectGrid.
			Replace	the type __CellType to whatever type you have in your grid.

			You can call the method anywhere in your code.
			
				if(!__CompilerHint__Rect()) return;

			This methods always returns true.

			@since 1.6
		*/
		public static bool __CompilerHint1__Rect()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new RectGrid<__CellType[]>(1, 1);

			foreach(var point in grid)
			{
				grid[point] = new __CellType[1];
			} 

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<RectPoint>(new IntRect(), p => true);
			var shapeInfo = new RectShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()][0] == null || shapeInfo.Translate(RectPoint.Zero) != null;
		}

		public static bool __CompilerHint2__Rect()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new RectGrid<__CellType>(1, 1, p => p == RectPoint.Zero, x => x, x => x, new List<RectPoint>());

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<RectPoint>(new IntRect(), p => true);
			var shapeInfo = new RectShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()] == null || shapeInfo.Translate(RectPoint.Zero) != null;
		}


		public static bool __CompilerHint__Diamond()
		{
			return __CompilerHint1__Diamond() && __CompilerHint2__Diamond();
		}

		/** 
			Call this method if you use a DiamondGrid.
			Replace	the type __CellType to whatever type you have in your grid.

			You can call the method anywhere in your code.
			
				if(!__CompilerHint__Diamond()) return;

			This methods always returns true.

			@since 1.6
		*/
		public static bool __CompilerHint1__Diamond()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new DiamondGrid<__CellType[]>(1, 1);

			foreach(var point in grid)
			{
				grid[point] = new __CellType[1];
			} 

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<DiamondPoint>(new IntRect(), p => true);
			var shapeInfo = new DiamondShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()][0] == null || shapeInfo.Translate(DiamondPoint.Zero) != null;
		}

		public static bool __CompilerHint2__Diamond()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new DiamondGrid<__CellType>(1, 1, p => p == DiamondPoint.Zero, x => x, x => x, new List<DiamondPoint>());

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<DiamondPoint>(new IntRect(), p => true);
			var shapeInfo = new DiamondShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()] == null || shapeInfo.Translate(DiamondPoint.Zero) != null;
		}

	}
}
#endif
